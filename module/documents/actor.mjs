/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
export class DragonBallUniverseActor extends Actor {
  /** @override */
  prepareData() {
    // Prepare data for the actor. Calling the super version of this executes
    // the following, in order: data reset (to clear active effects),
    // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
    // prepareDerivedData().
    super.prepareData();
  }

  /** @override */
  prepareBaseData() {
    // Data modifications in this step occur before processing embedded
    // documents or derived data.
  }

  /**
   * @override
   * Augment the actor source data with additional dynamic data that isn't
   * handled by the actor's DataModel. Data calculated in this step should be
   * available both inside and outside of character sheets (such as if an actor
   * is queried and has a roll executed directly from it).
   */
  prepareDerivedData() {
    const actorData = this;
    const flags = actorData.flags.dragonballuniverse || {};

    this._prepareCharacterData(actorData);

    console.log(actorData);
  }

  _prepareCharacterData(actorData) {
    if (actorData.type !== "character") return;

    const systemData = actorData.system;

    const level = systemData.attributes.level.value;

    /* Calculate the Tier of Power */

    systemData.baseTierOfPower = Math.floor(level / 5) + 1;

    systemData.currentTierOfPower = systemData.baseTierOfPower; // + any temporary modifiers from effects, transformations, etc.

    const abilities = systemData.abilities;

    this._prepareResourcesData(systemData, abilities, level);

    this._prepareAptitudesData(systemData, abilities);
  }

  _prepareResourcesData(systemData, abilities, level) {
    /* Calculate Life Modifier */

    // Each point of Tenacity adds 2 Life Points.
    const tenacityLifeModifier = abilities.te.value * 2 * level;

    // Each level after the first adds 12 Life Points.
    const levelLifeModifier = 12 * (level - 1);

    // Set the actor's max health to the base 60 + modifiers.
    systemData.health.max = 60 + tenacityLifeModifier + levelLifeModifier;

    /* Calculate Ki Points */

    const levelKiModifier = 12 * (level - 1);

    const baseKiPoints = 50 + levelKiModifier;

    const KiPointsBeforeMultiplier = baseKiPoints;

    const totalKiPoints = KiPointsBeforeMultiplier;

    systemData.ki.max = totalKiPoints;

    /* Calculate Capacity Rate */

    const levelCapacityRateModifier = 4 * (level - 1);

    systemData.capacityRate.max = 20 + levelCapacityRateModifier;
  }

  _prepareAptitudesData(systemData, abilities) {
    /* Declare aptitudes */

    // Agility aptitudes

    systemData.haste = Math.floor(abilities.ag.mod / 2);

    systemData.defenseValue = abilities.ag.mod;

    systemData.initiative = Math.floor(abilities.ag.value / 2);

    // Might aptitude

    systemData.might = Math.max(abilities.fo.mod, abilities.ma.mod);

    // Force aptitudes / rules

    systemData.surgency = abilities.fo.mod;

    systemData.superStackAmount = Math.clamp(
      Math.floor((abilities.fo.value - abilities.ag.value) / 5),
      0,
      3
    );

    // Tenacity aptitudes

    systemData.soak = abilities.te.mod;

    // Scholarship aptitudes / rules

    systemData.giftedStudentSkillBonus = Math.clamp(
      Math.floor(abilities.sc.value / 4),
      0,
      2
    );

    systemData.giftedStudentTpImprovement = Math.clamp(
      Math.floor(abilities.sc.value / 4),
      0,
      2
    );

    // Insight aptitudes

    systemData.awareness = abilities.in.mod;

    // Personality aptitudes

    systemData.determination = Math.clamp(
      Math.floor(abilities.pe.value / 4),
      0,
      2
    );

    // Saving Throws
    systemData.savingThrows = {
      corporeal: abilities.te.value,
      cognitive: abilities.in.value,
      morale: abilities.pe.value,
      impulsive: abilities.ag.value,
    };
  }

  /**
   *
   * @override
   * Augment the actor's default getRollData() method by appending the data object
   * generated by the its DataModel's getRollData(), or null. This polymorphic
   * approach is useful when you have actors & items that share a parent Document,
   * but have slightly different data preparation needs.
   */
  getRollData() {
    return { ...super.getRollData(), ...(this.system.getRollData?.() ?? null) };
  }
}
